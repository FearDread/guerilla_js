
var argRgx, doForAll, fnRgx, getArgumentNames, runFirst, runParallel, runSeries, runWaterfall, util,
  slice = [].slice;

fnRgx = /function[^(]*\(([^)]*)\)/;

argRgx = /([^\s,]+)/g;

getArgumentNames = function(fn) {
  var ref;
  return ((fn != null ? (ref = fn.toString().match(fnRgx)) != null ? ref[1] : void 0 : void 0) || '').match(argRgx) || [];
};

runParallel = function(tasks, cb, force) {
  var count, errors, hasErr, i, j, len, results, results1, t;
  if (tasks == null) {
    tasks = [];
  }
  if (cb == null) {
    cb = (function() {});
  }
  count = tasks.length;
  results = [];
  if (count === 0) {
    return cb(null, results);
  }
  errors = [];
  hasErr = false;
  results1 = [];
  for (i = j = 0, len = tasks.length; j < len; i = ++j) {
    t = tasks[i];
    results1.push((function(t, i) {
      var e, next;
      next = function() {
        var err, res;
        err = arguments[0], res = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (err) {
          errors[i] = err;
          hasErr = true;
          if (!force) {
            return cb(errors, results);
          }
        } else {
          results[i] = res.length < 2 ? res[0] : res;
        }
        if (--count <= 0) {
          if (hasErr) {
            return cb(errors, results);
          } else {
            return cb(null, results);
          }
        }
      };
      try {
        return t(next);
      } catch (_error) {
        e = _error;
        return next(e);
      }
    })(t, i));
  }
  return results1;
};

runSeries = function(tasks, cb, force) {
  var count, errors, hasErr, i, next, results;
  if (tasks == null) {
    tasks = [];
  }
  if (cb == null) {
    cb = (function() {});
  }
  i = -1;
  count = tasks.length;
  results = [];
  if (count === 0) {
    return cb(null, results);
  }
  errors = [];
  hasErr = false;
  next = function() {
    var e, err, res;
    err = arguments[0], res = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (err) {
      errors[i] = err;
      hasErr = true;
      if (!force) {
        return cb(errors, results);
      }
    } else {
      if (i > -1) {
        results[i] = res.length < 2 ? res[0] : res;
      }
    }
    if (++i >= count) {
      if (hasErr) {
        return cb(errors, results);
      } else {
        return cb(null, results);
      }
    } else {
      try {
        return tasks[i](next);
      } catch (_error) {
        e = _error;
        return next(e);
      }
    }
  };
  return next();
};

runFirst = function(tasks, cb, force) {
  var count, errors, i, next, result;
  if (tasks == null) {
    tasks = [];
  }
  if (cb == null) {
    cb = (function() {});
  }
  i = -1;
  count = tasks.length;
  result = null;
  if (count === 0) {
    return cb(null);
  }
  errors = [];
  next = function() {
    var e, err, res;
    err = arguments[0], res = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (err) {
      errors[i] = err;
      if (!force) {
        return cb(errors);
      }
    } else {
      if (i > -1) {
        return cb(null, res.length < 2 ? res[0] : res);
      }
    }
    if (++i >= count) {
      return cb(errors);
    } else {
      try {
        return tasks[i](next);
      } catch (_error) {
        e = _error;
        return next(e);
      }
    }
  };
  return next();
};

runWaterfall = function(tasks, cb) {
  var i, next;
  i = -1;
  if (tasks.length === 0) {
    return cb();
  }
  next = function() {
    var err, res;
    err = arguments[0], res = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (err != null) {
      return cb(err);
    }
    if (++i >= tasks.length) {
      return cb.apply(null, [null].concat(slice.call(res)));
    } else {
      return tasks[i].apply(tasks, slice.call(res).concat([next]));
    }
  };
  return next();
};

doForAll = function(args, fn, cb, force) {
  var a, tasks;
  if (args == null) {
    args = [];
  }
  tasks = (function() {
    var j, len, results1;
    results1 = [];
    for (j = 0, len = args.length; j < len; j++) {
      a = args[j];
      results1.push((function(a) {
        return function(next) {
          return fn(a, next);
        };
      })(a));
    }
    return results1;
  })();
  return util.runParallel(tasks, cb, force);
};

util = {
  doForAll: doForAll,
  runParallel: runParallel,
  runSeries: runSeries,
  runFirst: runFirst,
  runWaterfall: runWaterfall,
  getArgumentNames: getArgumentNames,
  hasArgument: function(fn, idx) {
    if (idx == null) {
      idx = 1;
    }
    return util.getArgumentNames(fn).length >= idx;
  }
};

// ---
// generated by coffee-script 1.9.2

